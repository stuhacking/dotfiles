#! /usr/bin/env python
#
# tinc -- There Is No Cabal
# Utility for automatic management of .cabal files.
#
# Created: 02-Oct-2012
#
# This utility will take a number of options and add them to
# a .cabal file using the command line. An output file may be
# specified. If the output file is not specified then try to
# detect if one exists in the current directory. Exit with
# failure otherwise.
#
# Usage examples:
# [1] tinc show author          => Prints author field
# [2] tinc set  author "John"   => Sets author field to "John"
# [3] tinc add-build-exe "game" => adds an executable section
# [4] tinc add-build-exe "game" main-is Main.hs hs-source-dirs src
#
# TODO: Most support for editing cabal files -- in progress
# TODO:  - Support for build sections
# TODO:  - Sensible ordering of 'significant' flags
#
import sys
import subprocess
import os
import re

# Version of cabal file format we intend to output.
target_cabal_version = [1, 2, 0]

# Target cabal filename - should be specified or detected.
cabal_filename = None

### SYSTEM COMMANDS ###

# Return username of current user.
def username():
    return subprocess.check_output(["whoami"])

# Return all or part of the installed cabal version
# 'full'    - the full string, e.g. 1.12.3, 1.2.34.12
# 'major'   - Just the major version, e.g. 1
# 'minor'   - Just the minor version, e.g. 14
# 'release' - Two part release version, e.g. 1.14
# default = full
def cabal_version_string(version, parts='full'):
    if parts == "major":
        return str(version[0])
    elif parts == "minor":
        return str(version[1])
    elif parts == 'release':
        return str(version[0]) + '.' + str(version[1])
    else:
        ver = ""
        for part in version:
            ver += str(part) + "."
        return ver[:-1]
    
# Turn a text cabal version string into a version triplet.
# Convert the parameter string, or return the installed
# cabal version if no parameter is passed.
def cabal_version(version_string=None):
    if version_string is None:
        cabal_version_string = subprocess.check_output(["cabal", "--version"]).split(' ')[4]
    else:
        cabal_version_string = version_string
        if version_string.startswith('>='):
            cabal_version_string = version_string[2:]
    return [int(x) for x in cabal_version_string.split('.') if x]

# Attempt to find a cabal file in the current working
# directory and return the filename.
# (If multiple cabal files exist, return the first one
# encountered.)
def guess_cabal_file():
    files = os.listdir(os.getcwd())
    for file in files:
        if (file.endswith('.cabal')):
            return file
    return None

# Ensure that cabal_filename has a value.
# Fail if unable to find a reasonable guess.
def ensure_cabal_filename():
    global cabal_filename
    if (cabal_filename is None):
        cabal_filename = guess_cabal_file()

    if (cabal_filename is None):
        print "Unable to Determine Cabal file."
        exit(1)

### CABAL FILE STRUCTURES ###

class Cabal_File:
    """
    A Cabal_File is a simple representation of the contents
    of a .cabal file on disk. It can be read and written.
    Writes will always overwrite the target file completely
    (reorganising the sections per the command given).
    """
    class Cabal_Section:
        """
        Cabal File section, e.g. A build config section.
        (Just a struct with named slots.)
        """
        def __init__(self, stype, name):
            self.stype = stype
            self.name = name
            self.fields = {}
            
    def __init__(self, filename):
        self.filename = filename
        self.fields = {}
        self.sections = []

        # Ensure filename ends with .cabal
        # Try not to require the user to be explicit.
        if (not filename.endswith('.cabal')):
            self.filename += '.cabal'

    def read(self):
        """
        Read the contents of self.filename.
        """
        with open(self.filename, "r") as f:
            for line in f:
                data = [x.strip(' ') for x in line[:-1].split(':') if x]
                if (len(data) >= 2):
                    self.fields[data[0]] = data[1]
            del self.fields['name']

    def write(self):
        """
        Write the Cabal File to self.filename.
        """
        global target_cabal_version

        if not self.fields.has_key('author'):
            self.set('author', username())

        if not self.fields.has_key('cabal-version'):
            self.set('cabal-version', cabal_version_string(target_cabal_version))

        with open(self.filename + '_test', "w") as f:
            f.write("name: " + self.filename.split('.cabal')[0] + '\n')
            for key in self.fields.keys():
                f.write(key + ": " + self.fields[key] + "\n")

    def show(self, fieldname):
        """
        Display the requested field, if present.
        Otherwise, gracefully display an error.
        """
        try:
            print self.fields[fieldname]
        except KeyError:
            print >> sys.stderr, "No such field -- ", fieldname

    def set(self, fieldname, value):
        """
        Add or overwrite the field with value.
        """
        # Release string is enough for cabal version.
        if fieldname == 'cabal-version':
            value = '>=' + cabal_version_string(cabal_version(value),
                                                parts='release')

        self.fields[fieldname] = value

### USAGE AND ARGUMENT PARSING ###

# Display usage and exit with failure.
def usage():
    print "Usage: tinc <command> [options]"
    print "options:"
    print " -h --help    - Display this help message."
    print " -o --output  - Specify output cabal file."
    print "Use \"tinc <command> --help for command specific options"
    exit(1)

def usage_show():
    print "Usage: tinc show [options] [field ...]"
    print "options:"
    print " -h --help    - Display this help message."
    print " -o --output  - Specify output cabal file."
    exit(1)

def usage_set():
    print "Usage: tinc set [options] [field value ...]"
    print "options:"
    print " -h --help    - Display this help message."
    print " -o --output  - Specify output cabal file."
    exit(1)

def usage_create():
    print "Usage: tinc create [options] [field value ...]"
    print "options:"
    print " -h --help    - Display this help message."
    print " -o --output  - Specify output cabal file."
    exit(1)

# Commands that inspect the contents of an existing
# cabal file.
def show(args):
    global cabal_filename
    fieldnames = []

    while (len(args) > 0):
        arg, args = args[0], args[1:]

        if re.match('^--?h(elp)?$', arg):
            usage_show()

        elif re.match('^--?o(utput)?$', arg):
            cabal_filename, args = args[0], args[1:]

        else:
            fieldnames += [arg]

    ensure_cabal_filename()

    cabal_file = Cabal_File(cabal_filename)
    cabal_file.read()

    for field in fieldnames:
        cabal_file.show(field)

# Commands that update fields in a cabal file.
def set_(args):
    global cabal_filename
    fields = []

    while (len(args) > 0):
        arg, args = args[0], args[1:]

        if re.match('^--?h(elp)?$', arg):
            usage_set()

        elif re.match('^--?o(utput)?$', arg):
            cabal_filename, args = args[0], args[1:]

        else:
            if (len(args) >= 1):
                fields.append((arg, args[0]))
                args = args[1:]


    ensure_cabal_filename()
    
    cabal_file = Cabal_File(cabal_filename)
    cabal_file.read()

    for field in fields:
        cabal_file.set(field[0], field[1])

    cabal_file.write()


# Create a new cabal file.
def create(args):
    global cabal_filename
    fields = []

    while (len(args) > 0):
        arg, args = args[0], args[1:]

        if re.match('^--?h(elp)?$', arg):
            usage_create()

        elif re.match('^--?o(utput)?$', arg):
            cabal_filename, args = args[0], args[1:]

        else:
            if (len(args) >= 1):
                fields.append((arg, args[0]))
                args = args[1:]

    ensure_cabal_filename()

    cabal_file = Cabal_File(cabal_filename)

    for field in fields:
        cabal_file.set(field[0], field[1])

    cabal_file.write()

def main():
    global cabal_filename
    args = sys.argv[1:]

    if (len(args) <= 0):
        usage()

    while (len(args) > 0):
        arg, args = args[0], args[1:]

        # Help Flag
        if re.match('^--?h(elp)?$', arg):
            usage()

        # Output File
        elif re.match('^--?o(utput)?$', arg):
            cabal_filename, args = args[0], args[1:]

        else:
            command = arg
            break

    if (command == 'show'):
        show(args)
    elif (command == 'set'):
        set_(args)
    elif (command == 'create'):
        create(args)
    else:
        print "unknown command -- ", command
        usage()

# Script Entrypoint
if __name__ == '__main__':
    main()
    sys.exit(0)

# tinc ends here.

